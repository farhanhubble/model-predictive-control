# Model Predictive Control
Driving a car in a simulator using a predictive model based on the car's kinematics.

---
![Driving car in isimulator](/res/mpc_small.gif)
## About 
This repository contains the code for model predictive control project of Udacity's [Self-driving Car Nanodegree](https://in.udacity.com/course/self-driving-car-engineer-nanodegree--nd013). Model Predictive Control or [MPC](https://en.wikipedia.org/wiki/Model_predictive_control) casts the pronblem of controlling a system, in this case a car, as an optimization problem. The MPC algorithm takes as input a reference trajectory and a vehicle model and produces a set of control inputs, steering angle, brake, throttle etc., that minimize a cost function over a finite number of timesteps, called the horizon.

The input model used here is a kinematic model which contains parameters like speed, position, heading etc. A more comprehensive dynamic model would also include forces, like friction and centripetal force and the torques produced by these forces. Dynamic models are computationally heavy.

The cost function used here includes the lateral deviation of the car called cross-track error, the difference between the actual and a reference velocity, and the error between the desired heading and the actual heading. Additionally steering angle and throttle value is added to the cost function so that thes variables do not assume very large variables during the optimization. 

## Getting a Reference Trajectory
A reference trajectory is needed to calculate the initial values of the state variables. The reference trajectory is computed in two steps from raw waypoints.

1. The waypoints are transformed from the a global coordinate system to the car's coordinate system with x axis pointing in the direction of the car's motion and y axis 90 degree clock wise from x axis. This also means that the current position of the car becomes x=0, y=0 and psi=0. This simplifies a lot of computation and plotting.

2. A third order polynomial is fit to the transformed coordinates. Such a ploynomial is flexible enough to fit almost all kinds of trajectories without being to wiggly.


## Building a  Model.
The MPC algorithm iimplemented here uses the velocity (**v**), x position (**x**), y position (**y**), heading (**psi**), cross-track error (**ct\_err**), the heading error (**psi\_err**) as input state variables. Steering angle (**delta**) and throttle (**a**) as additional state variables. 

The MPC algorithm  `MPC::solve()` takes the initial values of the input state variables (**v**, **x**, **y**, **psi**, **ct\_err**, **psi\_err**, **delta**, **a**) and wraps them using the `CppAD::AD` type. The type is defined in the **CppAD** library and allows us to build diffferentiable types from ordinary values. The algorithm also computes future values of these variables (`Cpp::AD type`) over **N** timesteps, each **dt** seconds long, using the equation of kinematics:

```
x_{t+1} = x_{t} + v_{t} * cos(psi_{t}) * dt;
y_{t+1} = y_{t} + v_{t} * sin(psi_{t}) * dt;
psi_{t+1} = psi_{t} * v_{t} * delta_{t} * dt / Lf
v_{t+1} = v_{t} + a_{t} * dt
cte_{t+1} = cte_{t} + v_{t} * sin(psi_{t}) * dt
epsi_{t+1} = epsi_{t} + v_{t} * delta_{t} * dt / Lf

Lf = Distance between the center of gravity of the car and its front axle.
```

The MPC algorithm then calculates a cost function that is the sum of squares of quantities that we want to minimize, for example the sum of square of **ct\_err** values and **psi\_err** over all **N** timesteps.

```
cost =  (cte_{t}^2) + (cte_{t+1}^2) + (cte_{t+2}^2) + ... + (cte_{t+N-1}^2)
cost += (epsi_{t}^2) + (epsi_{t+1}^2) + (epsi_{t+2}^2) + ... + (epsi_{t+N-1}^2)
```

Additional terms have been added to the cost function to ensure that optimization does not produce very large values of the variables or abrupt changes in the values from one timesptep to the next. For example the square of the steering angle at all **N-1** timesteps is also added:

```
cost += (delta_{t+1}^2) + (delta_{t+2}^2) + ... + (delta_{t+N-1}^2)
```

The MPC algorithm then minimizes the cost function with respect to all the variables, using the dependency generated by the equations of kinematics to constrain the possible values of the variables.

Afte the optimization is over, the values of the steering angle (**delta\_{t}**) and throttle(**a\_{t}**) are used to control the vehicle for a short time period, after which the MPC algorithm is rerun with the updated values of the state variables.


## Hyperparameter Tuning
**N** and **dt**, as described above, are hyper parameters of the algorithm. The granularity of the MPC algorithm depends on these hyperparameters and in turn affects the stability and accuracy of the car's motion. These parameters depend to a large extent on the vehicles velocity and the latency (fixed at 100ms). For a reference velocity of 40m/s the values of N=15 and dt=0.1s were found using trial and error.

If **N**\***dt** is made too small, the prediction horizon shrinks close to the present time and optimal values of steeing angle and throttle become obsolete by the time they're calculated. If **N**\***dt** is very large the cost is based on predictions far ahead in the future and the values of steeering and throttle are not so relevant to current time and the computation time of the algorithm also increases.

In addition to these explicit hypermaters, different components of the **cost** variable were multiplied by different weights. The sums of the steering angle and throttle were emphasized some 50X more than other variables so that they don't grow too large. For exact values of these hypermaters please refer to the [code](https://github.com/farhanhubble/model-predictive-control/blob/a4ca4a3101437491d907fb9928c16a3f3c6bdfc2/src/MPC.cpp#L70-L84). 


---

# Installation 

## Dependencies

* cmake >= 3.5
 * All OSes: [click here for installation instructions](https://cmake.org/install/)
* make >= 4.1(mac, linux), 3.81(Windows)
  * Linux: make is installed by default on most Linux distros
  * Mac: [install Xcode command line tools to get make](https://developer.apple.com/xcode/features/)
  * Windows: [Click here for installation instructions](http://gnuwin32.sourceforge.net/packages/make.htm)
* gcc/g++ >= 5.4
  * Linux: gcc / g++ is installed by default on most Linux distros
  * Mac: same deal as make - [install Xcode command line tools]((https://developer.apple.com/xcode/features/)
  * Windows: recommend using [MinGW](http://www.mingw.org/)
* [uWebSockets](https://github.com/uWebSockets/uWebSockets)
  * Run either `install-mac.sh` or `install-ubuntu.sh`.
  * If you install from source, checkout to commit `e94b6e1`, i.e.
    ```
    git clone https://github.com/uWebSockets/uWebSockets
    cd uWebSockets
    git checkout e94b6e1
    ```
    Some function signatures have changed in v0.14.x. See [this PR](https://github.com/udacity/CarND-MPC-Project/pull/3) for more details.

* **Ipopt and CppAD:** Please refer to [this document](https://github.com/udacity/CarND-MPC-Project/blob/master/install_Ipopt_CppAD.md) for installation instructions.
* [Eigen](http://eigen.tuxfamily.org/index.php?title=Main_Page). This is already part of the repo so you shouldn't have to worry about it.
* Simulator. You can download these from the [releases tab](https://github.com/udacity/self-driving-car-sim/releases).
* Not a dependency but read the [DATA.md](./DATA.md) for a description of the data sent back from the simulator.


## Basic Build Instructions

1. Clone this repo.
2. Make a build directory: `mkdir build && cd build`
3. Compile: `cmake .. && make`
4. Run it: `./mpc`.
